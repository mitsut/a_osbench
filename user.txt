
		TOPPERS/A-OSBENCH
		ユーザーズマニュアル

		最終更新：2016年5月7日
		Release 1.1

このドキュメントは，TOPPERS/A-OSBENCHを使用するために必要な事項を説明
するものである．

----------------------------------------------------------------------
TOPPERS/A-OSBENCH
    Toyohashi Open Platform for Embedded Real-Time Systems
    Automotive Operating System Benchmark

Copyright (C) 2014 by Center for Embedded Computing Systems
            Graduate School of Information Science, Nagoya Univ., JAPAN
Copyright (C) 2014 by FUJISOFT INCORPORATED, JAPAN
Copyright (C) 2014 by Sunny Giken Inc., JAPAN

上記著作権者は，以下の (1)～(3)の条件を満たす場合に限り，本ドキュメ
ント（本ドキュメントを改変したものを含む．以下同じ）を使用・複製・改
変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
(1) 本ドキュメントを利用する場合には，上記の著作権表示，この利用条件
    および下記の無保証規定が，そのままの形でドキュメント中に含まれて
    いること．
(2) 本ドキュメントを改変する場合には，ドキュメントを改変した旨の記述
    を，改変後のドキュメント中に含めること．ただし，改変後のドキュメ
    ントが，TOPPERSプロジェクト指定の開発成果物である場合には，この限
    りではない．
(3) 本ドキュメントの利用により直接的または間接的に生じるいかなる損害
    からも，上記著作権者およびTOPPERSプロジェクトを免責すること．また，
    本ドキュメントのユーザまたはエンドユーザからのいかなる理由に基づ
    く請求からも，上記著作権者およびTOPPERSプロジェクトを免責すること．

本ドキュメントは，AUTOSAR（AUTomotive Open System ARchitecture）仕様
に基づいている．上記の許諾は，AUTOSARの知的財産権を許諾するものではな
い．AUTOSARは，AUTOSAR仕様に基づいたソフトウェアを商用目的で利用する
者に対して，AUTOSARパートナーになることを求めている．

本ドキュメントは，無保証で提供されているものである．上記著作権者およ
びTOPPERSプロジェクトは，本ドキュメントに関して，特定の使用目的に対す
る適合性も含めて，いかなる保証も行わない．また，本ドキュメントの利用
により直接的または間接的に生じたいかなる損害に関しても，その責任を負
わない．

$Id: user.txt 658 2016-05-07 01:05:17Z ertl-honda $
----------------------------------------------------------------------

○はじめに

TOPPERS/A-OSBENCHは，AUTOSAR OS仕様(R4.0.3)準拠のRTOSで提供するシステム
サービスの処理時間を計測するAUTOSAR_OS性能評価仕様書に準拠した実行時間
性能評価プログラムである．

対象とするAUTOSAR OSのスケーラビリティクラスはSC1/SC1-MC，SC3/SC3-MCに
限定している．

参考資料として使用したTOPPERSから公開されているatk2のユーザードキュメ
ントを参照しておくとよい．

○AUTOSAR OS性能評価仕様書

本性能評価プログラムが対応するAUTOSAR OS性能評価仕様書のバージョンは，

  Release 1.1
  
である．  

○動作確認済みターゲット

ATK2の以下のバージョンで動作確認を行っている．

・atk2-sc1_nios2_dev_gcc-20151225.tar.gz
  SC : SC1
  プロセッサ : Nios2
  非依存部のバージョン : 1.4.0
  
・atk2-sc3_nios2_dev_gcc-20151225.tar.gz
  SC : SC3
  プロセッサ : Nios2
  非依存部のバージョン : 1.4.0
  
・atk2-sc1-mc_nios2_dev_gcc-20151225.tar.gz
  SC : SC1-MC
  プロセッサ : Nios2
  非依存部のバージョン : 1.4.0
  
・atk2-sc3-mc_nios2_dev_gcc-20151225.tar.gz
  SC : SC3-MC
  プロセッサ : Nios2
  非依存部のバージョン : 1.4.0
    
また，全SC共通評価(perf_eval_commn)については，以下のターゲットでも動
作確認を行った．

・atk2-sc1_hsbrh850f1l_ghs-20160106.tar.gz
  SC : SC1
  プロセッサ : RH850F1H
  非依存部のバージョン : 1.4.0
  
・atk2-sc3_hsbrh850f1l_ghs-20160318.tar.gz
  SC : SC3
  プロセッサ : RH850F1H
  非依存部のバージョン : 1.4.0
    
・atk2-sc1_rh850f1h_pb_ghs-20160106.tar.gz
  SC : SC1
  プロセッサ : RH850F1H
  非依存部のバージョン : 1.4.0
  
・atk2-sc3_rh850f1h_pb_ghs-20160318.tar.gz
  SC : SC3
  プロセッサ : RH850F1H
  非依存部のバージョン : 1.4.0

○同梱ドキュメント

./doc 以下に以下のドキュメントを置いている．

AUTOSAR_OS性能評価仕様書.pdf       : AUTOSAR OS性能評価仕様書
version.txt                        : バージョン情報


○ 目次
１．プログラムの構成
２．評価プログラムの流れ
３．評価プログラム使用と確認を行う手順について
４．実装が必要な部分について
    4.1  テストライブラリOS依存部
    4.2  テストライブラリターゲット依存部
    4.3  計測ログ出力
５．コンフィギュレーションについて
    5.1  非信頼で使用するライブラリのコンフィギュレーションについて
６．評価プログラムの実行
    6.1  マクロ定数について
    6.2  シーケンスチェック
７．実行時間計測の実現と測定方法
    7.1  実行時間計測環境の構築
    7.2  実行時間計測方法について
    7.3  実行時間計測回数について
    7.4  実行時間計測オーバヘッドの計測
    7.5  キャッシュによる実行時間計測の影響
８．時間計測妥当性評価
    8.1  100[us]の確認
    8.2  10[sec]の確認
９．計測した実行時間の見方
１０．評価プログラムで使用するタスクについて
    10.1  MainTask
    10.2  ResetTask
    10.3  S_IdleTask
１１．改訂履歴


１．プログラムの構成

プログラムは主に次のものより構成される．

評価プログラム(perf_eval)
  フォルダ
    - perf_eval_common    : SC1/SC3共通評価フォルダ
      - perf_general      : 全SC共通評価フォルダ
      - perf_star_shut    : 起動処理評価フォルダ(シングルコア)
      - perf_star_shut_mc : 起動処理評価フォルダ(マルチコア)
    - perf_eval_sc3       : SC3対象評価フォルダ
      - perf_general      : SC3評価項目フォルダ
      - perf_prohook      : プロテクションフック評価フォルダ
      - perf_terapp_a     : TerminateApplication(TerApp-1)処理評価フォルダ
      - perf_terapp_b     : TerminateApplication(TerApp-2)処理評価フォルダ
    - multi               : マルチコア評価フォルダ
    - single              : シングルコア評価フォルダ
    - atk2                : atk2対象フォルダ
    - obj_nios2_dev       : nios2ターゲット対象フォルダ
    - object_xx           : カーネルオブジェクト数別のコンフィギュレーションパターン対象フォルダ
    - osap_xx             : OSAP数別のコンフィギュレーションパターン対象フォルダ

  ファイル
    - perf_general_main_task.c : 評価プログラムMain処理本体(perf_generalのみ)
    - perf_xxx.c        : 評価プログラム本体(SC1対象ファイル)
    - perf_xxx_t.c      : 評価プログラム本体(信頼OSアプリケーション)
    - perf_xxx_nt.c     : 評価プログラム本体(非信頼OSアプリケーション)
    - perf_xxx.arxml    : 評価プログラムのコンフィギュレーション記述ファイル
    - perf_xxx.yaml     : arxmlファイルを作成するための元ファイル
    - perf_xxx.h        : 評価プログラムのヘッダファイル
    - perf_xxx_t.h      : perf_xxx_t.cのヘッダファイル(信頼OSアプリケーション)
    - perf_xxx_nt.h     : perf_xxx_nt.cのヘッダファイル(非信頼OSアプリケーション)
    - Rte_Type.h        : RTEヘッダファイル

テストライブラリ(library)
  - common        : テストライブラリ共通部
  - implement     : テストライブラリOS依存部
  - target        : テストライブラリターゲット依存部
  - obj_nios2_dev : テストライブラリnios2ターゲット依存部
  - sample        : テストライブラリターゲット依存部サンプル用


２．評価プログラムの流れ

評価プログラム処理本体は下記の次のシーケンスでRTOSの性能評価を行なっている．
 perf_eval_common/
  - perf_general : perf_general/(使用するOS)/perf_general_main_task.c
      実行時間計測関数の実行オーバヘッド測定
      100[us]の確認
      10[sec]の確認
      ActivateTask
        (Act-1)
        (Act-2)
        (Act-3)
        (Act-4)
      ActivateTask(MC) [multiのみ]
        (Act-5) 
        (Act-6)
        (Act-7)
      TerminateTask
        (Ter-1)
      ChainTask
        (Chain-1)
      Interrupt
        (Dis-1)
        (Ena-1)
        (Sus-1)
        (Res-1)
      Event
        (ClearE-1)
        (GetE-1)
        (WaitE-1)
        (WaitE-2)
      SetEvent
        (SetE-1)
        (SetE-2)
        (SetE-3)
      SetEvent(MC) [multiのみ]
        (SetE-4)
        (SetE-5)
        (SetE-6)
      Spinlock [multiのみ]
        (GetS-1)
        (RelS-1)
      IOC
        (IocS-1)
        (IocS-2)
        (IocR-1)
        (IocR-2)
        (IocR-3)
      IOC(MC)[multiのみ]
        (IocS-3)
        (IocS-4)
        (IocR-4)
        (IocR-5)
        (IocR-6)
      ISR2_A
        (Int-1)
        (Int-2)*
      ISR2_B
        (Int-3)
      ISR2_C_MC) [multiのみ]
        (Int-3)
      ISR2_A
        (Int-2)*

    【注意】* 
        ISR2_Aは 評価項目(Int-1), (Int-2) の評価順序がシーケンシャルではない．
        (Int-2) は OSがIDLE状態のときの割込み応答性能を評価しているため
        プログラムの最後で行なっている。

  - perf_star_shut : perf_star_shut/(使用するOS)/perf_star_shut.c
      Start_Shutdown
        実行時間計測関数の実行オーバヘッド測定
        (Star-1)

  - perf_star_shut_mc : perf_star_shut_mc/(使用するOS)/perf_star_shut.c
      Start_Shutdown(MC)
        実行時間計測関数の実行オーバヘッド測定
        (Star-1)

 perf_eval_sc3/
  - perf_general : perf_general/(使用するOS)/perf_general_main_task.c
      実行時間計測関数の実行オーバヘッド測定
      100[us]の確認
      10[sec]の確認
      TrustedFunction
        (Tfn-1)
        (Tfn-2)
      TerApp_C
        (TerApp-3)
      TerApp_D
        (TerApp-4)
      TerApp_E
        (TerApp-5)
      TerApp_F
        (TerApp-6)
      TerApp(MC) [multiのみ]
        (TerApp-7)
        (TerApp-8)
      ChkMem
        (ChkMem-1)

  - perf_prohook : perf_prohook/(使用するOS)/perf_prohook_t.c
      ProtectionHook_A
        実行時間計測関数の実行オーバヘッド測定
        (ProHook-1)
        (ProHook-2)
        (ProHook-3)
        (ProHook-4)
      ProtectionHook_B
        (ProHook-5)

  - perf_terapp_a : perf_terapp_a/(使用するOS)/(各コンフィギュレーションパターン)/perf_terapp_t.c
      TerApp_A
        実行時間計測関数の実行オーバヘッド測定
        (TerApp-1)

  - perf_terapp_b : perf_terapp_b/(使用するOS)/(各コンフィギュレーションパターン)/perf_terapp_t.c
      TerApp_B
        実行時間計測関数の実行オーバヘッド測定
        (TerApp-2)

(Act-1)などの内容については[1]を参照．


３．評価プログラム使用と確認を行う手順について

本評価プログラムを使用する流れとして下記の手順で確認を行う必要がある．

(1) 評価プログラムで使用するライブラリのOS依存部，ターゲット依存部，
    キャッシュパージについて実装する．
    依存部の実装が必要な箇所は「４．実装が必要な部分について」を参照すること．
    キャッシュパージの必要性については「7.4  実行時間計測オーバヘッドの計測」を参照すること．

(2) 使用するOSに合わせてコンフィギュレーションの設定を行う．
    設定に考慮が必要な箇所は「５．コンフィギュレーションについて」を参照すること．

(3) 評価プログラム実行する．
    シーケンスチェックの確認
      詳細は「6.2 シーケンスチェック」を参照すること．

    100[us]の確認
      詳細は「8.1 100[us]の確認」を参照すること．

    10[sec]の確認
      詳細は「8.2  10[sec]の確認」を参照すること．

    オーバヘッドの確認
      詳細は「7.4  実行時間計測オーバヘッドの計測」を参照すること．

    計測方法の確認
      詳細は「7.2  実行時間計測方法について」を参照すること．

    計測結果の確認
      詳細は「９．計測した実行時間の見方」を参照すること．


４．実装が必要な部分について

性能評価プログラムを動作させる場合，
実装が必要な関数はサンプルを用意しているが，関数内には必要な処理について
コメントのみ記載しているため，各依存部ごとにコメントに沿った実装が必要となる．

4.1 テストライブラリOS依存部

テストプログラムのlibrary/implement内で定義している関数は，OS管理情報
の内部データを確認する処理であることから，library/implement/内で定義している関数を
OS別に用意する必要がある．

参考として，OS依存部の処理は，library/implement/sampleにファイルと
必要なAPIを格納している．

実際にOS依存部のフォルダ作成する場合には"sample"の部分を作成するOSの名称
にする

4.2 テストライブラリターゲット依存部

計測タイマの使用方法は，ターゲットボードごとに違うものとして，
違うボードで動作させるためには，library/target内で定義している関数を
用意する必要がある．

参考として，OS依存部の処理は，library/terget/sampleにファイルと
必要なAPIを格納している．

実際にターゲット依存部のフォルダ作成する場合にはフォルダ名の"sample"の部分を
作成するターゲットの名称にする

4.3 計測ログ出力

評価プログラム内では，実行結果の表示やユーザへのメッセージ表示は，
シリアル出力を介して行なわれる前提としている．
この出力関数には 4.1 テストライブラリOS依存部に含まれる関数である，
test_outputlog関数を使用している．
test_outputlog関数は下記の4種類を用途によって使い分ける．
 ・void test_outputlog_0(const char8* Format)
 ・void test_outputlog_1(const char8* Format, sintptr Arg1)
 ・void test_outputlog_2(const char8* Format, sintptr Arg1, sintptr Arg2)
 ・void test_outputlog_3(const char8* Format, sintptr Arg1, sintptr Arg2, sintptr Arg3)
   [概要]  : メッセージ出力を行なうシリアル出力関数
   [使い方]: 第1引数のFormatにメッセージのフォーマット記述，
             第2引数以降(Arg1～Arg3)はフォーマット記述中で参照される値となり，
             printfのフォーマット記述のサブセットとなっている．
             またtest_outputlog_xのxの値はフォーマット記述中で参照する値の数
             によって使い分ける必要がある．
   [用例]:
      test_outputlog_0("Hello world");
      test_outputlog_1("Hello world in %d", year);

シリアル出力とは限らずとも，test_outputlogへの入力内容を何らかの
方法で出力できなければ計測結果の取得はできない．


５．コンフィギュレーションについて

コンフィギュレーションで指定する内容はOSごとに拡張されているものと
思われる．使用するOSに合わせ，別の形で設定する必要がある．

設定が必要な部分は，(Int-1～4)で使用する割込み応答性を確認する部分で，
割込みを入れる手段である．

評価項目によって割込みを使用しているため，割込み優先度と割込み番号について
はOSごとにコンフィギュレーションの設定が必要となる．
割込み番号は下記のマクロをライブラリで定義しているため，
ターゲット別に任意の割込み番号をマクロに定義してテストライブラリ内にある
割込み発生，クリア関数の引数で使用すること．

＜割込み番号のマクロ＞
   INTNO_ACTISR2_1
   INTNO_ACTISR2_2
   INTNO_ACTISR2_3
   INTNO_RESOURCE
   INTNO_SET_EVENT_1
   INTNO_SET_EVENT_2
   INTNO_TERAPP_F1
   INTNO_TERAPP_F2
   INTNO_TERAPP_F3
   INTNO_TERAPP_F4
   INTNO_PROHOOK_A
   INTNO_INT_A_TIMER 
   INTNO_INT_B_TIMER 
   INTNO_INT_MC_TIMER

＜割込み処理で使用する関数＞
   test_int_raise(割込み番号のマクロ)     : 割込み要求開始
   test_clear_int_req(割込み番号のマクロ) : 割込み要求クリア
   
本評価プログラムでは各OSのコンテナ及びパラメータの設定値を記載している
.yamlファイルをツールにて.arxmlファイルに変換して使用している．
変換方法及びツールの使用方法についてはTOPPERSから公開されているatk2-sc1の
atk2-sc1\utils\abrex\readme.txtを参照すること．

5.1  非信頼で使用するライブラリのコンフィギュレーションについて

非信頼OSアプリケーションの評価プログラムでは下記のライブラリの関数使用している．
しかし明示にアクセス許可がされていないOSAPより，ライブラリによって使用している
タイマー等周辺デバイスやメモリ領域のアクセスができない可能性がある．

例としてbegin_measureやend_measureではタイマレジスタのアクセスを行っているため，
タイマレジスタのメモリ領域を非信頼OSアプリケーションからアクセスできるように
共有領域に配置するコンフィギュレーションを使用するOSに合わせて設定する必要がある．

他にも下記のライブラリ関数をを使用するにあたり，非信頼OSアプリケーションで使用するに
辺り，ライブラリで使用する変数をアクセスする際のセクション領域についても考慮が必要となる．

＜非信頼で使用しているライブラリの関数＞
   test_init_check_cnt
   test_check_point
   test_mc_check_point
   test_int_raise
   begin_measure
   end_measure
   int_timer_initialize
   int_timer_terminate
   test_barrier_sync


６．評価プログラムの実行

評価プログラムの実行方法については使用するOSや環境で異なるため
詳細は本テキストでは記載しない．

＜perf_generalをatk2-sc3(ターゲットnios2)で評価する実行例＞
(1) 下記のようにOSを配置している任意のフォルダと同階層にrtos_eval_progフォルダを配置する．
    任意のフォルダ/
      atk2-sc3_x.x.x/
      rtos_eval_prog/

    x.x.x はバージョン番号にする．
    sc3以外(SC1/SC1-MC，SC3-MC)で使用する場合も上記と同様に配置する．

(2) rtos_eval_progフォルダ内にある下記のMakefileがあるパスまで移動する．
    perf_eval/perf_eval_common/perf_general/atk2/sc3/single/obj_nios2_dev
    perf_general以外の評価項目を動作する場合も同様にMakefileの
    配置している箇所まで移動する．

(3) makeコマンド(make depend, make)を実行する．

(4) プログラムの実行(make run)する

6.1 マクロ定数について

以下のマクロについては定義した状態でコンパイルされている必要がある．

MEASURE_100_NANO :
    print_hist() での表示形式が xx.x [us] になる
    評価用タイマーの精度が 100 [ns] であることを表す
LOOP_COUNT :
    性能評価の実行回数を表す
MAX_TIME :
MAX_TIME_100US :
    begin_measure()/end_measure()で計測できる単位時間の上限
    MEASURE_100_NANO が有効で，この値が 300 の場合は，300 * 100 [ns] 
    つまり，30[us] を上限として実行時間計測できることを意味している
TotalNumberOfCores :
    コンフィギュレータで定義される，OSで使われるコアの数
    マルチコア非対応OSの場合，このマクロ定数は定義されない
NO_LOOP1 :
    100[us] ループを作るための，ループ回数(100[us]の確認を参照)

以下のマクロについては条件に応じてユーザが任意に指定することが可能なものである．

USE_MC_KERNEL :
    マルチコア対応カーネルを使用する際に定義する
USE_SCALABILITYCLASS3 :
    SC3対応カーネルを使用する際に定義する
VALIDATE_SEQUENCE
    シーケンスチェックを実施することを示すマクロ．
    RTOS性能評価を行なうときは必ずコメントアウトすること．
SLAVE_IDLE_TASK :
    OSのアイドル処理をアイドルタスク(S_IdleTask)で実現する際に定義する．

6.2 シーケンスチェック

評価プログラムには，意図した順序でプログラムが動いているか(処理単位に
遷移しているか)をチェックするためのマクロが埋め込まれている．
それが，"SEQUENCE_CHECK(coreid, cnt)" である．

シーケンスのチェックはマクロ定数 VALIDATE_SEQUENCE が定義されているとき
のみ有効になる．シーケンスチェックを行なう場合はまず最初に
SEQUENCE_CHECK_START() を呼出す必要がある．これの実体はテストライブラリ共通部で
実装しているtest_init_check_cnt()であり，シーケンスチェックに使用するカウンタの
初期化を行なう関数になっている．

SEQUENCE_CHECK(coreid, cnt) の使い方であるが，coreid には その処理単位
が属するコア番号(OS_CORE_ID_MASTER ないし OS_CORE_ID_SLAVE)を指定し，
cnt には シーケンシャルな番号を指定する．
シーケンシャルな番号とは，1 から 1ずつ増えていく番号であり，数を飛ばす
ことは認められない．
1 の次は必ず 2 であり，2 の次は必ず 3 となるように設定する．

指定したシーケンスの順序通りに処理が行なわれると，

------------------------------------
Core 0 : Check point 1 passed.
Core 0 : Check point 2 passed.
Core 0 : Check point 3 passed.
Core 0 : Check point 4 passed.
Core 0 : Check point 5 passed.
...
Core 0 : Check point 1 passed.
Core 0 : Check point 2 passed.
Core 0 : Check point 3 passed.
Core 0 : Check point 4 passed.
Core 0 : Check point 5 passed.
------------------------------------

のように，無事に SEQUENCE_CHECK() を通過したログが出力される．
シーケンスチェックについては2周行うため，上記の出力例のように
シーケンス番号が1～末番号を1セットとして，2回出力されることを確認する．
log_example/perf_eval/perf_eval_common/perf_general/atk2/sc1/multiのみ
シーケンスチェックの実例としてperf_pass_result.txtを格納している．

もしも，何らかの不具合でシーケンスの順序通りに処理が行なわれない場合は，

------------------------------------
Core 0 : Check point 1 passed.
Core 0 : Check point 2 passed.
Core 0 : Check point 3 passed.
## Core 0 : Unexpected Check Point : 6
## in "test_mc_check_point(0, 6)".
Kernel Exit...
------------------------------------

のように，エラーメッセージを出力して評価プログラムを終了する．
LOOP_COUNT が大きな値で かつ VALIDATE_SEQUENCE が定義されていると大量の
ログが出力されることになるので注意が必要．

シーケンスチェックはあくまでプログラムが意図した通りに動作しているかどうか
を確認するためのものであるので，RTOSの性能評価を実施するときには必ず
"VALIDATE_SEQUENCE" マクロを OFF にすべきである．

実際の計測前に一度，"VALIDATE_SEQUENCE" マクロを ONにした状態で，シーケンスチェック
に問題ないことを確認後，計測実施することを推奨する．


７．実行時間計測の実現と測定方法

7.1 実行時間計測環境の構築

計測時間の時刻を取得するために，一定時間毎にカウントアップ(またはカウントダウン)する
タイマ(フリーランニングタイマ)と，それを読む関数(時刻取得関数)を用意する．

フリーランニングタイマのカウントアップ周期を0.1μs程度とすることを推奨
するが，カウントアップ周期を0.1μsより長い値にしか設定できない場合には，
可能な限り短い値に設定して使用する. 

タイマ，時刻取得関数の実現方法の詳細については評価プログラムを使用するターゲットにより
実現方法が異なるため本テキストでは記載しない．

評価プログラムにて計測区間の前後で用意した時刻取得関数を呼びだして，その差
を求めることで対象の実行時間を計測し，その分布を取得し，出力する方法をとっている．

また評価プログラムではテストライブラリ内のperf_histogram.hにある，HIST_GET_TIMを
用意した時刻取得関数に定義して，HIST_CONV_TIMを定義して，時刻取得関数が返す時刻の差に
変換を加えてから，その分布を取得することで，この実行時間計測環境を容易に実現できる．

本評価プログラムでは上記で構築するフリーランタイマと割込み応答性評価を実施する
ためにタイマを用いて割込みを周期的に発生させる，周期タイマを用意する．

フリーランタイマと周期タイマの精度ついては100[ns]となるように調整する．
また結果出力についてはμsの単位に変換して表記する．

7.2 実行時間計測方法について

評価プログラムでは以下のような方法で実行時間の計測を行っている．
計測の対象となる処理の前にbegin_measure()関数を配置し，
計測の対象となる処理の後にend_measure()関数を配置して実行時間を計測する．

＜評価プログラムの例＞
------------------------------------------------------
begin_measure(); ---------------> 実行時間計測の開始
/* 実行時間を評価したい処理 */
end_measure();   ---------------> 実行時間計測の終了
------------------------------------------------------


7.3 実行時間計測回数について

評価プログラムの評価項目により実行計測回数が下記のように異なる．
  perf_star_shut/perf_star_shut_mcの計測回数は10回計測する．
  perf_terapp_a，perf_terapp_bの計測回数は1回計測する．
  perf_prohookは(ProHook-5)のみ1回計測する
  上記以外の各測定項目は，10000回計測する．

  perf_star_shut/perf_star_shut_mcは，1回のみの結果取得であるため
  10回分結果を取得するためには，それだけの回数を実行させる必要がある．
  perf_terapp_a，perf_terapp_b，perf_prohook(ProHook-5)の計測回数については
  計測時間の変化を見るのではなく，カーネルオブジェクト数のパターンで計測時間の変化を
  みるため，計測回数が1回のみの実行でよい．
  perf_generalのsingle/multiは，1回の実行で，計測回数10000回の実行を行うため，
  1回の実行でよい．
  計測回数はマクロ定数のLOOP_COUNTでユーザが任意の回数を指定することができる．


7.4 実行時間計測オーバヘッドの計測

実行時間の計測はbegin_measure()/end_measure()関数で取得した時刻の差分値をとって，
実行時間の算出を実現するが，当該関数の呼出しにかかる時間もそれに含まれてしまう．
評価プログラムでは，begin_measure()/end_measure()の実行オーバヘッドを考慮す
るために，プログラムの冒頭で実行オーバヘッドの値を計測している．

＜実行時間計測オーバヘッド計測の例＞
--------------------------------------------
/* 何も処理を挟まないことでオーバヘッドを計測 */
begin_measure();
end_measure();
--------------------------------------------

＜実行時間計測オーバヘッド出力結果の例＞
--------------------------------------------
== measure overhead ==
0.5     : 9999
0.6     : 1
--------------------------------------------

ここで出力された値を，グローバル変数である overhead_time に代入することで
各項目の計測結果が，実測値から，この実行時間計測にかかるオーバヘッドを
減じたものをprint_hist()関数にて出力することができる．


7.5 キャッシュによる実行時間計測の影響

キャッシュを持っているプロセッサで実行時間計測を行う場合は，計測開始の2回目
以降の実行ではほぼキャッシュがヒットするため，初回の実行に比べて短い時間となる．
そのため，実行時間の最頻値を取ると，キャッシュがほとんどヒットしている状態の
実行時間を求めていることになるが，実際のRTOSの実行時にキャッシュがほとんど
ヒットする状況は考えにくく，この方法で求めた実行時間計測の結果が妥当であるか
判断ができない．

そのため，キャッシュによって実行時間の計測値に影響が発生しないように，実行時間計測
の開始前に毎回キャッシュをパージして計測を行う．(キャッシュの全エントリを無効にする)

begin_measure()の処理内にあるHIST_BM_HOOKにキャッシュパージの処理を定義する
ことで計測前に毎回キャッシュパージを行ってから計測を実施することが可能となる．

パージするキャッシュについては命令キャッシュとデータキャッシュ共にパージできている
ことが望ましい．

キャッシュパージの詳細な実装方法についてはターゲット毎に異なるため，本テキストでは記載しない．


８．時間計測妥当性評価

8.1  100[us]の確認

評価プログラムの以下ブロックの実行によって，forループの実行時間が100[us]となるように
NO_LOOP1の値を調整し，プログラム実行毎 print_hist()での値がおよそ 100[us] となってい
ることを確認すること．
定数NO_LOOP1 は perf_general_t.h及びperf_general.h(SC1対象ファイル)で #define によって定義する．

--------------------------------------------
for(i = 0; i < LOOP_COUNT; i++) {
    begin_measure();
    /* jのループの実行時間が 100[us] となることを確認 */
    for(j = 0; j < NO_LOOP1; j++) {
    }
    end_measure();
}
--------------------------------------------

使用するCPUクロックに合わせてNO_LOOP1の値を設定し，
ログ上は以下のように出力されることを確認すること．

== 100us test ==
100.0   : 9999
100.1   : 1

なお，このNO_LOOP1の値はカテゴリー2ISR内での時間調整ほかに使われている．
またNO_LOOP1の値の設定の出力結果が大きく100[us]と離れてしまっている場合
カテゴリー2ISRの時間調整が正しくとれないため，処理の整合性が保てない且つ
計測処理時間について出力される値が妥当であるか判断できないため，


8.2  10[sec]の確認

このブロックは100[us]の確認の後にあり，通常はコメントアウトしてよい．
当該ブロックでは先に調整した NO_LOOP1 の妥当性を確認するものである．
ブロックでは 100[us]の確認で回したループ数の 100,000 倍のループを回
すことによって 10[sec] の時間を作り出している．
実際にストップウォッチなどでこのループの実行時間を測定し，本当に 10
[sec] かかっているかどうかを確認すること．
もしも，当該ブロックの実行時間が明らかに 10[sec] ではない場合は，
NO_LOOP1 の値の調整が再度必要となる．

--------------------------------------------
test_outputlog_0("== 10s test start ==");   /* ストップウォッチスタート */
loop = NO_LOOP1 * 100000;
for (j = 0; j < loop; j++) {
}
test_outputlog_0("== 10s test end ==");     /* ストップウォッチストップ */
--------------------------------------------


９．計測した実行時間の見方

print_hist で出力されるログの見方について 100[us]の確認ブロックを例に説明する．
ログ出力の左側の値が単位実行時間であり，右側の値がその頻度である．
本評価プログラムの場合，基本的に精度が 100[ns] の評価用タイマーを用いて実行
時間の計測を行なっているので単位実行時間は 100[ns] となる．
左側の値は表示単位を [us]を揃えているので，例えば， "10.2" と表示された場合は
実行時間は "10.2 [マイクロ秒]" である．
なお，1単位時間は "0.1" と表示され，実行時間は小数点第1位までの精度が保証される．

(実行結果)
== 100us test ==
100.5   : 91
100.6   : 5869
100.7   : 3557
100.8   : 482
100.9   : 1

この場合，100[us]ループの実行時間の計測を 10,000回行なった内，実行時間が
100.5[us] だったときが   91 回，
100.6[us] だったときが 5869 回，
100.7[us] だったときが 3557 回，
100.8[us] だったときが  482 回，
100.9[us] だったときが    1 回
であったということになる．


１０．評価プログラムで使用するタスクについて

10.1  MainTask

評価プログラムの計測処理の全体シーケンスは下記の実装例のように
必ずMainTaskから各評価項目で最初に起動するタスクを呼び出し，
評価対象の計測処理が完了したらはMainTaskへ戻るという処理を
LOOP_COUNT回数分行うシーケンスとしている．

LOOP_COUNTはperf_xxx_t.hで定義しているグローバル変数のため，
ユーザは任意の値を定義して計測回数を変更することが可能となる．

評価対象の処理シーケンスに問題があった場合はSEQUENCE_CHECKに
よって意図しない動作によって評価対象の処理が終了していないか確認が可能となる．

＜評価プログラム実装例＞
--------------------------------------------
MainTask()
{
	int		i,;
...
    for (i = 0; i < LOOP_COUNT; i++) {
        SEQUENCE_CHECK_START();
        SEQUENCE_CHECK(OS_CORE_ID_MASTER, 1);
        ActivateTask(xxx_Task2);
        SEQUENCE_CHECK(OS_CORE_ID_MASTER, 5);
    }
    計測結果の出力
...
}
--------------------------------------------

10.2  ResetTask

評価プログラムを動作する際に信頼OSアプリケーションから非信頼OSアプリケーション
のパターン計測時にMPUの切換えが発生するターゲット存在するため，
MPUの切換えの発生により処理時間の計測に影響する可能性がある．

計測対象の非信頼OSアプリケーションに所属するタスクを起動する前に
起動するタスクと同様の非信頼OSアプリケーションに所属する
xxx_ResetTaskを用意して対象のパターンの計測直前に起動することで，
MPUの切換えが発生しないようにしている
また，xxx_ResetTaskのタスク内は特に処理等は不要なため空としている．

--------------------------------------------
xxx_Task1()
{
...
    ActivateTask(xxx_ResetTask); ----->  xxx_Task2と同様の非信頼OSアプリケーションに所属する高優先度タスク

    /* 計測対象のタスク起動 */
    begin_measure();
    ActivateTask(xxx_Task2);     ----->  非信頼OSアプリケーションに所属するタスク
    end_measure();
...
}

--------------------------------------------


10.3  S_IdleTask

S_IdleTaskはOSのアイドル処理をタスクで実現したものである．
OSのアイドル処理はターゲット依存部によって仕様が異なることが
あるため，MCの計測はアイドル処理によって計測結果が変わる場合に，
本関数を使用する．
SLAVE_IDLE_TASKマクロを定義されているときのみに有効となる．
S_IdleTask内ではインライン関数のidle_task_processにユーザ指定の
コアIDを渡すことで，指定したコアに対してアイドル処理を実現することが可能となる．
idle_task_processは依存部の内容となるため，各依存部ごとに実装が必要となる．

--------------------------------------------
#ifdef SLAVE_IDLE_TASK
TASK(S_IdleTask)
{
	idle_task_process(コアID);
	TerminateTask();
}
#endif /* SLAVE_IDLE_TASK */
--------------------------------------------


１１．改訂履歴
2016/5/06 Release 1.1 : ATK2 1.4.0 及びRH850対応
2014/5/27 Release 1.0 : 最初のリリース

以上．
